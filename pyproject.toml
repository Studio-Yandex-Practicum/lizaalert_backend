# У Poetry два основных файла в корне проекта:
#   pyproject.toml - описывает зависимости верхнего уровня (абстрактные),
# те которые добавляет пользователь руками (django, DRF, flake8 и т.д.)
#   poetry.lock - содержит детерминированный снимок всех зависимостей и их
# подзависимостей с конкретными версиями и хеш-суммами пакетов. Создается
# автоматически, руками в него ничего не вносится.
#
# Принцип poetry:
#   Если при добавлении новой библиотеки в pyproject.toml её подзависимости
# будут совместимы с теми, что уже зафиксированы в poetry.lock (пусть они и не
# самые свежие), тогда имеющиеся в poetry.lock обновлены не будут, добавятся
# только недостающие.
#   Это позволяет фиксировать окружение для деплоя проекта в неизменном
# рабочем состоянии. Это и накладывает некоторые дополнительные сложности,
# в том числе при merge.
#
#
#   Есть два рабочих способа добавления или удаления новой библиотеки
# (обратите внимание, версии лучше указывать полностью фиксированные):
# 1) Через командную строку, например:
#    poetry add gunicorn="20.1.0" django="3.2.12"
#    poetry add --dev flake8="4.0.1"
#    poetry remove flake8
#
# 2) Напрямую вписав или удалив библиотеку в нужную секцию
#    (dependencies или dev-dependencies) в файле pyproject.toml. Но после
#    этого все равно нужно применить команду 'poetry add <new_package>', чтобы
#    в lock файле отобразились изменения (недоработанный костыль в poetry).
#    Например, можно добавить и удалить мелкую библиотеку без зависимостей:
#        poetry add pycowsay && poetry remove pycowsay
#
# Создание requirements.txt из poetry.lock (нужно выполнять после любого
# изменения зависимостей):
#        poetry export --without-hashes > ./lizaalert-backend/requirements.txt
#
# Внимание!
# Не используйте следующие команды, т.к. они полностью обновляют lock файл:
#   (НЕТ)   poetry lock
#   (НЕТ)   poetry update
#
#
# Концепция разрешения merge конфликтов:
# 1) - poetry.lock ВСЕГДА берем в неизменном виде из сливаемой ветки.
#    - pyproject.toml можно взять в неизменном виде, а можно смержить, воркфлоу
#        отличается незначительно (об этом ниже).
#    - requirements.txt - без разницы, т.к. все равно нужно будет создать новый.
# 2.1) Если pyproject.toml взяли в неизменном виде, то нужно добавить свои
#    библиотеки описанным выше первым способом:
#        poetry add <package1> <package2>
# 2.2) Если pyproject.toml смержили, т.е. в нем уже перечислены ваши
#    добавленные библиотеки, то применяем второй способ:
#        poetry add pycowsay && poetry remove pycowsay
# 3) Создаем requirements.txt:
#        poetry export --without-hashes > ./lizaalert-backend/requirements.txt
# 4) Добавляем все измененные файлы в индекс и коммитим.
#
#
# Один из вариантов разрешения merge конфликта:
#     git merge main              (сливаем ветку main к себе, возник конфликт)
#     git checkout --theirs poetry.lock        (берем весь файл из ветки main)
#     ........        (разрешаем конфликты в других файлах и в pyproject.toml)
#     poetry add pycowsay && poetry remove pycowsay
#     poetry export --without-hashes > ./lizaalert-backend/requirements.txt
#     git add .
#     git merge --continue                                          (коммитим)


[tool.poetry]
name = "lizaalert"
version = "0.1.0"
description = ""
authors = ["Lizaalert-backend-team"]

[tool.poetry.dependencies]
python = "^3.7.12"
Django = "3.2.12"
djangorestframework = "3.13.1"
environs = "9.5.0"
gunicorn = "20.1.0"
pydantic = "1.9.0"
psycopg2-binary = "2.9.3"
easy-thumbnails = "2.8.1"
phonenumbers = "8.12.45"
django-phonenumber-field = "6.1.0"

[tool.poetry.dev-dependencies]
flake8 = "4.0.1"
isort = "5.10.1"

[build-system]
requires = ["poetry-core>=1.0.0"]
build-backend = "poetry.core.masonry.api"
